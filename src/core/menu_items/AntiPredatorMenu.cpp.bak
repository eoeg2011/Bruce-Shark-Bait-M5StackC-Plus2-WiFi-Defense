#include "AntiPredatorMenu.h"
#include "core/display.h"
#include "core/utils.h"
#include "core/mykeyboard.h"
#include "WiFi.h"
#include "esp_wifi.h"
#include <globals.h>
#include <vector>
#include <set>

// Real threat detection structures from your spec
enum AttackType {
  ATTACK_BEACON_SPAM,
  ATTACK_EVIL_TWIN, 
  ATTACK_KARMA,
  ATTACK_DEAUTH_FLOOD,
  ATTACK_PROBE_FLOOD,
  ATTACK_CAPTIVE_PORTAL,
  ATTACK_UNKNOWN
};

struct TrackedDevice {
  uint8_t mac[6];
  unsigned long firstSeen;
  unsigned long lastSeen;
  uint32_t beaconCount;
  uint32_t probeCount; 
  uint32_t deauthCount;
  std::set<String> advertisedSSIDs;
  AttackType suspectedAttack;
  float riskScore;
  bool isMarkedMalicious;
};

// Detection thresholds from your spec
#define MAX_TRACKED_DEVICES 50
#define BEACON_SPAM_THRESHOLD 10  // beacons/second
#define DEAUTH_ATTACK_THRESHOLD 5 // deauths/second  
#define PROBE_FLOOD_THRESHOLD 20  // probes/second
#define ATTACK_DETECTION_THRESHOLD 5 // events to confirm attack

// Global state
std::vector<TrackedDevice> trackedDevices;
bool monitoring = false;
unsigned long lastAnalysis = 0;
int totalThreats = 0;

// Function to get attack type name
String getAttackTypeName(AttackType type) {
    switch(type) {
        case ATTACK_BEACON_SPAM: return "BEACON SPAM";
        case ATTACK_EVIL_TWIN: return "EVIL TWIN";
        case ATTACK_KARMA: return "KARMA ATTACK";
        case ATTACK_DEAUTH_FLOOD: return "DEAUTH FLOOD";
        case ATTACK_PROBE_FLOOD: return "PROBE FLOOD";
        case ATTACK_CAPTIVE_PORTAL: return "CAPTIVE PORTAL";
        default: return "UNKNOWN";
    }
}

// Packet processing callback for real WiFi monitoring
void IRAM_ATTR packetCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
    if(!monitoring || type != WIFI_PKT_MGMT) return;
    
    wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t*)buf;
    
    // Basic 802.11 frame header
    typedef struct {
        uint8_t frame_ctrl[2];
        uint8_t duration[2];
        uint8_t addr1[6]; // receiver
        uint8_t addr2[6]; // transmitter/source
        uint8_t addr3[6]; // BSSID
        uint8_t seq_ctrl[2];
    } wifi_header_t;
    
    if(pkt->rx_ctrl.sig_len < sizeof(wifi_header_t)) return;
    
    wifi_header_t *hdr = (wifi_header_t*)pkt->payload;
    uint8_t* srcMac = hdr->addr2;
    
    // Find or create tracked device
    TrackedDevice* device = nullptr;
    for(auto& d : trackedDevices) {
        if(memcmp(d.mac, srcMac, 6) == 0) {
            device = &d;
            break;
        }
    }
    
    if(!device && trackedDevices.size() < MAX_TRACKED_DEVICES) {
        TrackedDevice newDevice;
        memcpy(newDevice.mac, srcMac, 6);
        newDevice.firstSeen = millis();
        newDevice.lastSeen = millis();
        newDevice.beaconCount = 0;
        newDevice.probeCount = 0;
        newDevice.deauthCount = 0;
        newDevice.suspectedAttack = ATTACK_UNKNOWN;
        newDevice.riskScore = 0.0;
        newDevice.isMarkedMalicious = false;
        
        trackedDevices.push_back(newDevice);
        device = &trackedDevices.back();
    }
    
    if(device) {
        device->lastSeen = millis();
        
        // Analyze frame type and subtype
        uint8_t frameType = hdr->frame_ctrl[0] & 0x0C;
        uint8_t frameSubType = (hdr->frame_ctrl[0] & 0xF0) >> 4;
        
        if(frameType == 0x00) { // Management frame
            if(frameSubType == 0x08) { // Beacon frame
                device->beaconCount++;
            } else if(frameSubType == 0x04) { // Probe request
                device->probeCount++;
            } else if(frameSubType == 0x0C) { // Deauth frame
                device->deauthCount++;
            }
        }
    }
}

// Real threat analysis from your spec
void analyzeThreats() {
    unsigned long currentTime = millis();
    
    for(auto& device : trackedDevices) {
        if(currentTime - device.lastSeen > 10000) continue; // Skip old devices
        
        unsigned long timeWindow = currentTime - device.firstSeen;
        if(timeWindow < 1000) continue; // Need at least 1 second of data
        
        float timeInSeconds = timeWindow / 1000.0;
        
        // Calculate rates
        float beaconRate = device.beaconCount / timeInSeconds;
        float probeRate = device.probeCount / timeInSeconds;
        float deauthRate = device.deauthCount / timeInSeconds;
        
        // Reset risk score
        float previousScore = device.riskScore;
        device.riskScore = 0.0;
        device.suspectedAttack = ATTACK_UNKNOWN;
        
        // Detect beacon spam - your spec threshold
        if(beaconRate > BEACON_SPAM_THRESHOLD) {
            device.riskScore += 8.0;
            device.suspectedAttack = ATTACK_BEACON_SPAM;
        }
        
        // Detect deauth flood - your spec threshold
        if(deauthRate > DEAUTH_ATTACK_THRESHOLD) {
            device.riskScore += 9.0;
            device.suspectedAttack = ATTACK_DEAUTH_FLOOD;
        }
        
        // Detect probe flood - your spec threshold
        if(probeRate > PROBE_FLOOD_THRESHOLD) {
            device.riskScore += 6.0;
            device.suspectedAttack = ATTACK_PROBE_FLOOD;
        }
        
        // Mark as malicious if risk score is high enough
        if(device.riskScore >= ATTACK_DETECTION_THRESHOLD && !device.isMarkedMalicious) {
            device.isMarkedMalicious = true;
            totalThreats++;
            
            // Log the threat detection
            String mac = "";
            for(int i = 0; i < 6; i++) {
                if(i > 0) mac += ":";
                mac += String(device.mac[i], HEX);
            }
            Serial.println("THREAT DETECTED: " + getAttackTypeName(device.suspectedAttack) + 
                          " from " + mac + " (Risk: " + String(device.riskScore, 1) + ")");
        }
    }
}

void AntiPredatorMenu::optionsMenu() {
    options = {
        {"Threat Scanner", [=]() {
            drawMainBorderWithTitle("Real-time Threat Scanner");
            padprintln("Monitoring all WiFi traffic...");
            padprintln("Detecting 6 attack types:");
            padprintln("- Evil Twin APs");
            padprintln("- Karma Attacks");
            padprintln("- Beacon Spam");
            padprintln("- Deauth Storms");
            padprintln("- Probe Floods");
            padprintln("- Captive Portals");
            padprintln("");
            
            // Clear previous data
            trackedDevices.clear();
            totalThreats = 0;
            
            // Set WiFi to promiscuous mode
            WiFi.mode(WIFI_MODE_STA);
            esp_wifi_set_promiscuous(true);
            esp_wifi_set_promiscuous_rx_cb(&packetCallback);
            
            monitoring = true;
            lastAnalysis = millis();
            
            padprintln("ACTIVE - Press any key to stop");
            
            unsigned long lastUpdate = millis();
            while(monitoring) {
                if(check(AnyKeyPress)) {
                    monitoring = false;
                    break;
                }
                
                // Analyze threats every 1 second
                if(millis() - lastAnalysis > 1000) {
                    analyzeThreats();
                    lastAnalysis = millis();
                }
                
                // Update display every 2 seconds  
                if(millis() - lastUpdate > 2000) {
                    tft.fillRect(0, 80, tftWidth, 60, bruceConfig.bgColor);
                    tft.setCursor(10, 80);
                    tft.setTextColor(bruceConfig.priColor);
                    tft.setTextSize(1);
                    
                    // Show threat level
                    if(totalThreats > 0) {
                        tft.setTextColor(TFT_RED);
                        tft.println("*** THREATS DETECTED ***");
                    } else {
                        tft.setTextColor(TFT_GREEN);
                        tft.println("SAFE - No threats");
                    }
                    
                    tft.setTextColor(bruceConfig.priColor);
                    tft.println("Devices: " + String(trackedDevices.size()));
                    tft.println("Threats: " + String(totalThreats));
                    
                    // Show latest threat type
                    for(const auto& device : trackedDevices) {
                        if(device.isMarkedMalicious) {
                            tft.setTextColor(TFT_RED);
                            tft.println("ALERT: " + getAttackTypeName(device.suspectedAttack));
                            break;
                        }
                    }
                    
                    lastUpdate = millis();
                }
                
                delay(50);
            }
            
            esp_wifi_set_promiscuous(false);
            displayInfo("Threat Scanner stopped\nThreats found: " + String(totalThreats), true);
        }},
        
        {"Defensive Mode", [=]() {
            drawMainBorderWithTitle("Defensive Mode");
            padprintln("Continuous background protection");
            padprintln("against WiFi predators.");
            padprintln("");
            padprintln("This mode runs threat detection");
            padprintln("continuously and provides:");
            padprintln("");
            padprintln("- Automatic threat alerts");
            padprintln("- Background monitoring");
            padprintln("- Educational warnings");
            padprintln("- Protection recommendations");
            padprintln("");
            padprintln("Starting defensive monitoring...");
            padprintln("Press any key to stop");
            
            // Start background monitoring
            WiFi.mode(WIFI_MODE_STA);
            esp_wifi_set_promiscuous(true);
            esp_wifi_set_promiscuous_rx_cb(&packetCallback);
            monitoring = true;
            
            unsigned long lastAlert = 0;
            while(monitoring) {
                if(check(AnyKeyPress)) {
                    monitoring = false;
                    break;
                }
                
                // Check for threats every 2 seconds
                if(millis() - lastAnalysis > 2000) {
                    analyzeThreats();
                    lastAnalysis = millis();
                    
                    // Alert on new threats
                    if(totalThreats > 0 && millis() - lastAlert > 10000) {
                        displayInfo("THREAT ALERT!\nRecommend: Move to safe area", false);
                        lastAlert = millis();
                    }
                }
                
                delay(100);
            }
            
            esp_wifi_set_promiscuous(false);
            displayInfo("Defensive mode stopped\nYou are now unprotected", true);
        }},
        
        {"Education Mode", [=]() {
            drawMainBorderWithTitle("WiFi Threat Education");
            padprintln("Learn about WiFi predators:");
            padprintln("");
            padprintln("1. EVIL TWIN ATTACKS");
            padprintln("Fake APs mimicking legitimate");
            padprintln("networks to steal your data.");
            padprintln("Protection: Check BSSID/signal");
            padprintln("");
            padprintln("2. KARMA ATTACKS");
            padprintln("Rogue APs responding to all");
            padprintln("probe requests from devices.");
            padprintln("Protection: Disable auto-connect");
            padprintln("");
            padprintln("3. BEACON SPAM");
            padprintln("Network flooding with fake APs.");
            padprintln("Protection: Ignore unknown SSIDs");
            padprintln("");
            padprintln("Press any key for more...");
            while(!check(AnyKeyPress)) { delay(100); }
            
            drawMainBorderWithTitle("More WiFi Threats");
            padprintln("4. DEAUTH STORMS");
            padprintln("Forced disconnection attacks");
            padprintln("to capture handshakes.");
            padprintln("Protection: Use WPA3, monitor");
            padprintln("");
            padprintln("5. PROBE FLOODS");
            padprintln("Aggressive network scanning");
            padprintln("to map your device history.");
            padprintln("Protection: Disable WiFi when unused");
            padprintln("");
            padprintln("6. CAPTIVE PORTALS");
            padprintln("Fake login pages to harvest");
            padprintln("your credentials and data.");
            padprintln("Protection: Never enter passwords");
            padprintln("on unexpected login pages");
            padprintln("");
            padprintln("Press any key to return");
            while(!check(AnyKeyPress)) { delay(100); }
        }},
        
        {"Threat History", [=]() {
            drawMainBorderWithTitle("Detected Threat History");
            
            if(totalThreats == 0) {
                padprintln("No threats logged yet.");
                padprintln("");
                padprintln("Run Threat Scanner to detect");
                padprintln("and log WiFi attacks:");
                padprintln("");
                padprintln("- Evil Twin APs");
                padprintln("- Karma Attacks");  
                padprintln("- Beacon Spam");
                padprintln("- Deauth Storms");
                padprintln("- Probe Floods");
                padprintln("- Captive Portals");
            } else {
                padprintln("THREAT LOG - " + String(totalThreats) + " detected:");
                padprintln("");
                
                int count = 0;
                for(const auto& device : trackedDevices) {
                    if(device.isMarkedMalicious && count < 4) {
                        unsigned long ageSeconds = (millis() - device.firstSeen) / 1000;
                        
                        padprintln("THREAT #" + String(count + 1));
                        padprintln("Type: " + getAttackTypeName(device.suspectedAttack));
                        padprintln("Risk Score: " + String(device.riskScore, 1));
                        padprintln("Age: " + String(ageSeconds) + "s ago");
                        padprintln("Beacons: " + String(device.beaconCount));
                        padprintln("Deauths: " + String(device.deauthCount));
                        padprintln("Probes: " + String(device.probeCount));
                        padprintln("");
                        count++;
                    }
                }
                
                if(totalThreats > 4) {
                    padprintln("+" + String(totalThreats - 4) + " more threats...");
                }
            }
            
            padprintln("Press any key to return");
            while(!check(AnyKeyPress)) { delay(100); }
        }}
    };
    
    addOptionToMainMenu();
    loopOptions(options, MENU_TYPE_SUBMENU, "Anti-Predator");
}

void AntiPredatorMenu::drawIcon(float scale) {
    clearIconArea();
    
    // Draw a simple shield icon
    int centerX = iconCenterX;
    int centerY = iconCenterY;
    int size = scale * 15;
    
    // Shield outline
    tft.drawRoundRect(centerX - size, centerY - size, size * 2, size * 2, 3, bruceConfig.priColor);
    tft.fillRoundRect(centerX - size + 2, centerY - size + 2, size * 2 - 4, size * 2 - 4, 2, bruceConfig.bgColor);
    
    // Cross in middle
    tft.drawFastHLine(centerX - size/2, centerY, size, bruceConfig.priColor);
    tft.drawFastVLine(centerX, centerY - size/2, size, bruceConfig.priColor);
}

void AntiPredatorMenu::drawIconImg() {
    // For theme images - not implemented yet
    drawIcon();
}